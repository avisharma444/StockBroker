{"ast":null,"code":"// src/utils.ts\nvar isServer = typeof window === \"undefined\" || \"Deno\" in globalThis;\n\nfunction noop() {\n  return void 0;\n}\n\nfunction functionalUpdate(updater, input) {\n  return typeof updater === \"function\" ? updater(input) : updater;\n}\n\nfunction isValidTimeout(value) {\n  return typeof value === \"number\" && value >= 0 && value !== Infinity;\n}\n\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\n\nfunction matchQuery(filters, query) {\n  const {\n    type = \"all\",\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== \"all\") {\n    const isActive = query.isActive();\n\n    if (type === \"active\" && !isActive) {\n      return false;\n    }\n\n    if (type === \"inactive\" && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === \"boolean\" && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    status,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (status && mutation.state.status !== status) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = options?.queryKeyHashFn || hashKey;\n  return hashFn(queryKey);\n}\n\nfunction hashKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n\nfunction partialMatchKey(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some(key => !partialMatchKey(a[key], b[key]));\n  }\n\n  return false;\n}\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aItems = array ? a : Object.keys(a);\n    const aSize = aItems.length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n\n      if (!array && a[key] === void 0 && b[key] === void 0 && aItems.includes(key)) {\n        copy[key] = void 0;\n        equalItems++;\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key]);\n\n        if (copy[key] === a[key] && a[key] !== void 0) {\n          equalItems++;\n        }\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n\nfunction shallowEqualObjects(a, b) {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n\n  const ctor = o.constructor;\n\n  if (ctor === void 0) {\n    return true;\n  }\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\n\nfunction sleep(ms) {\n  return new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n\nfunction replaceData(prevData, data, options) {\n  if (typeof options.structuralSharing === \"function\") {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nfunction keepPreviousData(previousData) {\n  return previousData;\n}\n\nfunction addToEnd(items, item) {\n  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const newItems = [...items, item];\n  return max && newItems.length > max ? newItems.slice(1) : newItems;\n}\n\nfunction addToStart(items, item) {\n  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const newItems = [item, ...items];\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n}\n\nvar skipToken = Symbol();\nexport { addToEnd, addToStart, functionalUpdate, hashKey, hashQueryKeyByOptions, isPlainArray, isPlainObject, isServer, isValidTimeout, keepPreviousData, matchMutation, matchQuery, noop, partialMatchKey, replaceData, replaceEqualDeep, shallowEqualObjects, skipToken, sleep, timeUntilStale };","map":{"version":3,"mappings":"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","names":["isServer","window","globalThis","noop","functionalUpdate","updater","input","isValidTimeout","value","Infinity","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","matchQuery","filters","query","type","exact","fetchStatus","predicate","queryKey","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","status","mutationKey","hashKey","hashFn","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","some","replaceEqualDeep","array","isPlainArray","aItems","aSize","length","bItems","bSize","copy","equalItems","i","includes","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","toString","call","sleep","ms","Promise","resolve","setTimeout","replaceData","prevData","data","structuralSharing","keepPreviousData","previousData","addToEnd","items","item","newItems","slice","addToStart","skipToken","Symbol"],"sources":["C:\\Users\\Avi Sharma\\Desktop\\zerodha_proj\\client2\\node_modules\\@tanstack\\query-core\\src\\utils.ts"],"sourcesContent":["import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationKey,\n  MutationStatus,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Filter by mutation status\n   */\n  status?: MutationStatus\n}\n\nexport type Updater<TInput, TOutput> = TOutput | ((input: TInput) => TOutput)\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in globalThis\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as (_: TInput) => TOutput)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, status, predicate, mutationKey } = filters\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (status && mutation.state.status !== status) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: Pick<QueryOptions<any, any, any, any>, 'queryKeyHashFn'>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query & mutation keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashKey(queryKey: QueryKey | MutationKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean\nexport function partialMatchKey(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aItems = array ? a : Object.keys(a)\n    const aSize = aItems.length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      if (\n        !array &&\n        a[key] === undefined &&\n        b[key] === undefined &&\n        aItems.includes(key)\n      ) {\n        copy[key] = undefined\n        equalItems++\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key])\n        if (copy[key] === a[key] && a[key] !== undefined) {\n          equalItems++\n        }\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects.\n */\nexport function shallowEqualObjects<T extends Record<string, any>>(\n  a: T,\n  b: T | undefined,\n): boolean {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has no constructor\n  const ctor = o.constructor\n  if (ctor === undefined) {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data) as TData\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n\nexport function keepPreviousData<T>(\n  previousData: T | undefined,\n): T | undefined {\n  return previousData\n}\n\nexport function addToEnd<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [...items, item]\n  return max && newItems.length > max ? newItems.slice(1) : newItems\n}\n\nexport function addToStart<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [item, ...items]\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems\n}\n\nexport const skipToken = Symbol()\nexport type SkipToken = typeof skipToken\n"]},"metadata":{},"sourceType":"module"}