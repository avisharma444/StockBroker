{"ast":null,"code":"// src/infiniteQueryBehavior.ts\nimport { addToEnd, addToStart, skipToken } from \"./utils.js\";\n\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      const fetchFn = async () => {\n        const options = context.options;\n        const direction = context.fetchOptions?.meta?.fetchMore?.direction;\n        const oldPages = context.state.data?.pages || [];\n        const oldPageParams = context.state.data?.pageParams || [];\n        const empty = {\n          pages: [],\n          pageParams: []\n        };\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, \"signal\", {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true;\n              } else {\n                context.signal.addEventListener(\"abort\", () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        };\n\n        const queryFn = context.options.queryFn && context.options.queryFn !== skipToken ? context.options.queryFn : () => {\n          if (process.env.NODE_ENV !== \"production\") {\n            if (context.options.queryFn === skipToken) {\n              console.error(`Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${context.options.queryHash}'`);\n            }\n          }\n\n          return Promise.reject(new Error(`Missing queryFn: '${context.options.queryHash}'`));\n        };\n\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? \"backward\" : \"forward\",\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const page = await queryFn(queryFnContext);\n          const {\n            maxPages\n          } = context.options;\n          const addTo = previous ? addToStart : addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n\n        let result;\n\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          result = await fetchPage(empty, oldPageParams[0] ?? options.initialPageParam);\n          const remainingPages = pages ?? oldPages.length;\n\n          for (let i = 1; i < remainingPages; i++) {\n            const param = getNextPageParam(options, result);\n            result = await fetchPage(result, param);\n          }\n        }\n\n        return result;\n      };\n\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(fetchFn, {\n            queryKey: context.queryKey,\n            meta: context.options.meta,\n            signal: context.signal\n          }, query);\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\n\nfunction getNextPageParam(options, _ref) {\n  let {\n    pages,\n    pageParams\n  } = _ref;\n  const lastIndex = pages.length - 1;\n  return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams);\n}\n\nfunction getPreviousPageParam(options, _ref2) {\n  let {\n    pages,\n    pageParams\n  } = _ref2;\n  return options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams);\n}\n\nfunction hasNextPage(options, data) {\n  if (!data) return false;\n  return getNextPageParam(options, data) != null;\n}\n\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam) return false;\n  return getPreviousPageParam(options, data) != null;\n}\n\nexport { hasNextPage, hasPreviousPage, infiniteQueryBehavior };","map":{"version":3,"mappings":"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","names":["addToEnd","addToStart","skipToken","infiniteQueryBehavior","pages","onFetch","context","query","fetchFn","options","direction","fetchOptions","meta","fetchMore","oldPages","state","data","oldPageParams","pageParams","empty","cancelled","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","aborted","addEventListener","queryFn","process","env","NODE_ENV","console","error","queryHash","Promise","reject","Error","fetchPage","param","previous","length","resolve","queryFnContext","queryKey","pageParam","page","maxPages","addTo","result","pageParamFn","getPreviousPageParam","getNextPageParam","oldData","initialPageParam","remainingPages","i","persister","lastIndex","hasNextPage","hasPreviousPage"],"sources":["C:\\Users\\Avi Sharma\\Desktop\\zerodha_proj\\client2\\node_modules\\@tanstack\\query-core\\src\\infiniteQueryBehavior.ts"],"sourcesContent":["import { addToEnd, addToStart, skipToken } from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context, query) => {\n      const fetchFn = async () => {\n        const options = context.options as InfiniteQueryPageParamsOptions<TData>\n        const direction = context.fetchOptions?.meta?.fetchMore?.direction\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        const empty = { pages: [], pageParams: [] }\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn && context.options.queryFn !== skipToken\n            ? context.options.queryFn\n            : () => {\n                if (process.env.NODE_ENV !== 'production') {\n                  if (context.options.queryFn === skipToken) {\n                    console.error(\n                      `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${context.options.queryHash}'`,\n                    )\n                  }\n                }\n                return Promise.reject(\n                  new Error(`Missing queryFn: '${context.options.queryHash}'`),\n                )\n              }\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const queryFnContext: OmitKeyof<\n            QueryFunctionContext<QueryKey, unknown>,\n            'signal'\n          > = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? 'backward' : 'forward',\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const page = await queryFn(\n            queryFnContext as QueryFunctionContext<QueryKey, unknown>,\n          )\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        let result: InfiniteData<unknown>\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          // Fetch first page\n          result = await fetchPage(\n            empty,\n            oldPageParams[0] ?? options.initialPageParam,\n          )\n\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch remaining pages\n          for (let i = 1; i < remainingPages; i++) {\n            const param = getNextPageParam(options, result)\n            result = await fetchPage(result, param)\n          }\n        }\n\n        return result\n      }\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn as any,\n            {\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal,\n            },\n            query,\n          )\n        }\n      } else {\n        context.fetchFn = fetchFn\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams,\n  )\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return options.getPreviousPageParam?.(\n    pages[0],\n    pages,\n    pageParams[0],\n    pageParams,\n  )\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n"]},"metadata":{},"sourceType":"module"}