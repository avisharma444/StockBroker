{"ast":null,"code":"// src/query.ts\nimport { noop, replaceData, skipToken, timeUntilStale } from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { canFetch, createRetryer, isCancelledError } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = class extends Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #retryer;\n  #observers;\n  #defaultOptions;\n  #abortSignalConsumed;\n\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.#observers = [];\n    this.#cache = config.cache;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = config.state || getDefaultState(this.options);\n    this.state = this.#initialState;\n    this.scheduleGc();\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.#defaultOptions,\n      ...options\n    };\n    this.updateGcTime(this.options.gcTime);\n  }\n\n  optionalRemove() {\n    if (!this.#observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.#dispatch({\n      type: \"setState\",\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    const promise = this.#retryer?.promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n\n  isActive() {\n    return this.#observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    if (this.state.isInvalidated) {\n      return true;\n    }\n\n    if (this.getObserversCount() > 0) {\n      return this.#observers.some(observer => observer.getCurrentResult().isStale);\n    }\n\n    return this.state.data === void 0;\n  }\n\n  isStaleByTime() {\n    let staleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    const observer = this.#observers.find(x => x.shouldFetchOnWindowFocus());\n    observer?.refetch({\n      cancelRefetch: false\n    });\n    this.#retryer?.continue();\n  }\n\n  onOnline() {\n    const observer = this.#observers.find(x => x.shouldFetchOnReconnect());\n    observer?.refetch({\n      cancelRefetch: false\n    });\n    this.#retryer?.continue();\n  }\n\n  addObserver(observer) {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({\n        type: \"observerAdded\",\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.#observers.includes(observer)) {\n      this.#observers = this.#observers.filter(x => x !== observer);\n\n      if (!this.#observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.#cache.notify({\n        type: \"observerRemoved\",\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.#observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({\n        type: \"invalidate\"\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== \"idle\") {\n      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {\n        this.cancel({\n          silent: true\n        });\n      } else if (this.#retryer) {\n        this.#retryer.continueRetry();\n        return this.#retryer.promise;\n      }\n    }\n\n    if (options) {\n      this.setOptions(options);\n    }\n\n    if (!this.options.queryFn) {\n      const observer = this.#observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(`As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`);\n      }\n    }\n\n    const abortController = new AbortController();\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      meta: this.meta\n    };\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext);\n\n    const fetchFn = () => {\n      if (process.env.NODE_ENV !== \"production\") {\n        if (this.options.queryFn === skipToken) {\n          console.error(`Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${this.options.queryHash}'`);\n        }\n      }\n\n      if (!this.options.queryFn || this.options.queryFn === skipToken) {\n        return Promise.reject(new Error(`Missing queryFn: '${this.options.queryHash}'`));\n      }\n\n      this.#abortSignalConsumed = false;\n\n      if (this.options.persister) {\n        return this.options.persister(this.options.queryFn, queryFnContext, this);\n      }\n\n      return this.options.queryFn(queryFnContext);\n    };\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    this.options.behavior?.onFetch(context, this);\n    this.#revertState = this.state;\n\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({\n        type: \"fetch\",\n        meta: context.fetchOptions?.meta\n      });\n    }\n\n    const onError = error => {\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: \"error\",\n          error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        this.#cache.config.onError?.(error, this);\n        this.#cache.config.onSettled?.(this.state.data, error, this);\n      }\n\n      if (!this.isFetchingOptimistic) {\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    };\n\n    this.#retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: data => {\n        if (data === void 0) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(`Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`);\n          }\n\n          onError(new Error(`${this.queryHash} data is undefined`));\n          return;\n        }\n\n        this.setData(data);\n        this.#cache.config.onSuccess?.(data, this);\n        this.#cache.config.onSettled?.(data, this.state.error, this);\n\n        if (!this.isFetchingOptimistic) {\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({\n          type: \"failed\",\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        this.#dispatch({\n          type: \"pause\"\n        });\n      },\n      onContinue: () => {\n        this.#dispatch({\n          type: \"continue\"\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    return this.#retryer.promise;\n  }\n\n  #dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case \"failed\":\n          return { ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n\n        case \"pause\":\n          return { ...state,\n            fetchStatus: \"paused\"\n          };\n\n        case \"continue\":\n          return { ...state,\n            fetchStatus: \"fetching\"\n          };\n\n        case \"fetch\":\n          return { ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null\n          };\n\n        case \"success\":\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...(!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n\n        case \"error\":\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState,\n              fetchStatus: \"idle\"\n            };\n          }\n\n          return { ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n\n        case \"invalidate\":\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case \"setState\":\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.#observers.forEach(observer => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({\n        query: this,\n        type: \"updated\",\n        action\n      });\n    });\n  }\n\n};\n\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? \"fetching\" : \"paused\",\n    ...(data === void 0 && {\n      error: null,\n      status: \"pending\"\n    })\n  };\n}\n\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\n\nexport { Query, fetchState };","map":{"version":3,"mappings":"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","names":["noop","replaceData","skipToken","timeUntilStale","notifyManager","canFetch","createRetryer","isCancelledError","Removable","Query","constructor","config","defaultOptions","setOptions","options","cache","queryKey","queryHash","state","getDefaultState","scheduleGc","meta","updateGcTime","gcTime","optionalRemove","length","fetchStatus","remove","setData","newData","data","type","dataUpdatedAt","updatedAt","manual","setState","setStateOptions","cancel","promise","then","catch","Promise","resolve","destroy","silent","reset","isActive","some","observer","enabled","isDisabled","getObserversCount","isStale","isInvalidated","getCurrentResult","isStaleByTime","staleTime","onFocus","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","onOnline","shouldFetchOnReconnect","addObserver","includes","push","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","invalidate","fetch","fetchOptions","continueRetry","queryFn","process","env","NODE_ENV","Array","isArray","console","error","abortController","AbortController","queryFnContext","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","fetchFn","reject","Error","persister","context","behavior","onFetch","fetchMeta","onError","onSettled","isFetchingOptimistic","fn","abort","bind","onSuccess","onFail","failureCount","onPause","onContinue","retry","retryDelay","networkMode","action","reducer","fetchFailureCount","fetchFailureReason","fetchState","dataUpdateCount","Date","now","status","errorUpdateCount","errorUpdatedAt","batch","forEach","onQueryUpdate","initialData","hasData","initialDataUpdatedAt"],"sources":["C:\\Users\\Avi Sharma\\Desktop\\zerodha_proj\\client2\\node_modules\\@tanstack\\query-core\\src\\query.ts"],"sourcesContent":["import { noop, replaceData, skipToken, timeUntilStale } from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n  isFetchingOptimistic?: boolean\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #retryer?: Retryer<TData>\n  #observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.#observers = []\n    this.#cache = config.cache\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = config.state || getDefaultState(this.options)\n    this.state = this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.#observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.#observers.some(\n      (observer) => observer.options.enabled !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    if (this.getObserversCount() > 0) {\n      return this.#observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      this.state.data === undefined ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.#observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.#observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.#observers.includes(observer)) {\n      this.#observers = this.#observers.filter((x) => x !== observer)\n\n      if (!this.#observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.#observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.#observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Create query function context\n    const queryFnContext: OmitKeyof<\n      QueryFunctionContext<TQueryKey>,\n      'signal'\n    > = {\n      queryKey: this.queryKey,\n      meta: this.meta,\n    }\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    addSignalProperty(queryFnContext)\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (this.options.queryFn === skipToken) {\n          console.error(\n            `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${this.options.queryHash}'`,\n          )\n        }\n      }\n\n      if (!this.options.queryFn || this.options.queryFn === skipToken) {\n        return Promise.reject(\n          new Error(`Missing queryFn: '${this.options.queryHash}'`),\n        )\n      }\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          this.options.queryFn,\n          queryFnContext as QueryFunctionContext<TQueryKey>,\n          this as unknown as Query,\n        )\n      }\n\n      return this.options.queryFn(\n        queryFnContext as QueryFunctionContext<TQueryKey>,\n      )\n    }\n\n    // Trigger behavior hook\n    const context: OmitKeyof<\n      FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      'signal'\n    > = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(\n      context as FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      this as unknown as Query,\n    )\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        this.setData(data)\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n    })\n\n    return this.#retryer.promise\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error as unknown\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error: error as TError,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error as TError,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"]},"metadata":{},"sourceType":"module"}