{"ast":null,"code":"// src/queryCache.ts\nimport { hashQueryKeyByOptions, matchQuery } from \"./utils.js\";\nimport { Query } from \"./query.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar QueryCache = class extends Subscribable {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.config = config;\n    this.#queries = /* @__PURE__ */new Map();\n  }\n\n  #queries;\n\n  build(client, options, state) {\n    const queryKey = options.queryKey;\n    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query);\n      this.notify({\n        type: \"added\",\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.#queries.get(query.queryHash);\n\n    if (queryInMap) {\n      query.destroy();\n\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash);\n      }\n\n      this.notify({\n        type: \"removed\",\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.getAll().forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.#queries.get(queryHash);\n  }\n\n  getAll() {\n    return [...this.#queries.values()];\n  }\n\n  find(filters) {\n    const defaultedFilters = {\n      exact: true,\n      ...filters\n    };\n    return this.getAll().find(query => matchQuery(defaultedFilters, query));\n  }\n\n  findAll() {\n    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const queries = this.getAll();\n    return Object.keys(filters).length > 0 ? queries.filter(query => matchQuery(filters, query)) : queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.getAll().forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.getAll().forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n};\nexport { QueryCache };","map":{"version":3,"mappings":"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","names":["hashQueryKeyByOptions","matchQuery","Query","notifyManager","Subscribable","QueryCache","constructor","config","Map","build","client","options","state","queryKey","queryHash","query","get","cache","defaultQueryOptions","defaultOptions","getQueryDefaults","add","has","set","notify","type","remove","queryInMap","destroy","delete","clear","batch","getAll","forEach","values","find","filters","defaultedFilters","exact","findAll","queries","Object","keys","length","filter","event","listeners","listener","onFocus","onOnline"],"sources":["C:\\Users\\Avi Sharma\\Desktop\\zerodha_proj\\client2\\node_modules\\@tanstack\\query-core\\src\\queryCache.ts"],"sourcesContent":["import { hashQueryKeyByOptions, matchQuery } from './utils'\nimport { Query } from './query'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport type { QueryFilters } from './utils'\nimport type { Action, QueryState } from './query'\nimport type {\n  DefaultError,\n  NotifyEvent,\n  QueryKey,\n  QueryOptions,\n  WithRequired,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (\n    error: DefaultError,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\nexport type QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\nexport interface QueryStore {\n  has: (queryHash: string) => boolean\n  set: (queryHash: string, query: Query) => void\n  get: (queryHash: string) => Query | undefined\n  delete: (queryHash: string) => void\n  values: () => IterableIterator<Query>\n}\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  #queries: QueryStore\n\n  constructor(public config: QueryCacheConfig = {}) {\n    super()\n    this.#queries = new Map<string, Query>()\n  }\n\n  build<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(\n    client: QueryClient,\n    options: WithRequired<\n      QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query)\n\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.#queries.get(query.queryHash)\n\n    if (queryInMap) {\n      query.destroy()\n\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash)\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.#queries.get(queryHash) as\n      | Query<TQueryFnData, TError, TData, TQueryKey>\n      | undefined\n  }\n\n  getAll(): Array<Query> {\n    return [...this.#queries.values()]\n  }\n\n  find<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData>(\n    filters: WithRequired<QueryFilters, 'queryKey'>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((query) =>\n      matchQuery(defaultedFilters, query),\n    ) as Query<TQueryFnData, TError, TData> | undefined\n  }\n\n  findAll(filters: QueryFilters = {}): Array<Query> {\n    const queries = this.getAll()\n    return Object.keys(filters).length > 0\n      ? queries.filter((query) => matchQuery(filters, query))\n      : queries\n  }\n\n  notify(event: QueryCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}